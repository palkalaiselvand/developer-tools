@page "/jwtdecoder"
@inject IJSRuntime JSRuntime
@using System.Text
@using System.Text.Json
@using System.Globalization
@using System.Linq
@using System.Security.Cryptography
@using System.Collections.Generic

<div class="max-w-screen-xl mx-auto space-y-8">
    <div>
        <h1 class="text-3xl font-bold text-gray-800">JWT Decoder</h1>
        <p class="text-gray-600 mt-2">
            Inspect JSON Web Tokens safely in your browser. Decode the header and payload, review key claims, and copy
            formatted JSON without sending your token across the network.
        </p>
    </div>

    <div class="bg-white rounded-lg shadow-md p-6 space-y-4">
        <label class="block text-sm font-medium text-gray-700" for="jwt-input">Paste a JWT</label>
        <textarea id="jwt-input"
                  @bind="jwtInput"
                  class="w-full h-40 border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm"
                  placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."></textarea>
        <div class="flex flex-wrap gap-3">
            <button class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors" @onclick="DecodeJwt">
                Decode token
            </button>
            <button class="px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 transition-colors" @onclick="ClearAll">
                Clear
            </button>
            <button class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors" @onclick="LoadSampleToken">
                Load sample token
            </button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div class="md:col-span-2">
                <label class="block text-sm font-medium text-gray-700 mb-1" for="jwt-secret">Verification secret (optional)</label>
                <div class="relative">
                    <input id="jwt-secret"
                           type="@(showSecret ? "text" : "password")"
                           @bind="verificationSecret"
                           @bind:event="oninput"
                           class="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm font-mono"
                           placeholder="Shared secret for HS256/HS384/HS512 tokens" />
                    <button type="button"
                            class="absolute inset-y-0 right-3 flex items-center text-gray-500 hover:text-gray-700"
                            @onclick="ToggleSecretVisibility"
                            title="Toggle visibility">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                    </button>
                </div>
            </div>
            <div class="text-xs text-gray-500 md:flex md:items-center">
                Provide the shared secret to validate HMAC signatures. Other algorithms require public keys and are not supported in-browser.
            </div>
        </div>

        <p class="text-xs text-gray-500">
            Tokens are decoded entirely in your browser. Secrets never leave this page.
        </p>
    </div>

    @if (decodeError is null && (tokenStatus != TokenStatus.Unavailable || signatureVerification.State != SignatureVerificationState.NotRequested))
    {
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            @if (tokenStatus != TokenStatus.Unavailable)
            {
                var style = GetTokenStatusStyle(tokenStatus);
                <div class="@($"rounded-md border-l-4 {style.BorderClass} {style.BackgroundClass} p-4")">
                    <h3 class="@($"text-sm font-semibold {style.TextClass}")">@style.Title</h3>
                    @if (!string.IsNullOrWhiteSpace(tokenLifetimeSummary))
                    {
                        <p class="@($"text-sm mt-1 {style.TextClass}")">@tokenLifetimeSummary</p>
                    }
                </div>
            }
            @if (signatureVerification.State != SignatureVerificationState.NotRequested)
            {
                var style = GetSignatureStatusStyle(signatureVerification.State);
                <div class="@($"rounded-md border-l-4 {style.BorderClass} {style.BackgroundClass} p-4")">
                    <h3 class="@($"text-sm font-semibold {style.TextClass}")">@style.Title</h3>
                    <p class="@($"text-sm mt-1 {style.TextClass}")">@signatureVerification.Message</p>
                </div>
            }
        </div>
    }

    @if (!string.IsNullOrWhiteSpace(decodeError))
    {
        <div class="rounded-md bg-red-50 border border-red-200 text-red-700 text-sm px-4 py-3">
            @decodeError
        </div>
    }
    else if (headerClaims is not null && payloadClaims is not null)
    {
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="bg-white rounded-lg shadow-md p-6 space-y-4">
                <div class="flex items-center justify-between">
                    <h2 class="text-xl font-semibold text-gray-800">Header</h2>
                    <button id="copy-header" class="text-gray-500 hover:text-gray-700" @onclick="CopyHeaderAsync" title="Copy header JSON">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                    </button>
                </div>
                <div class="bg-gray-50 border border-gray-200 rounded-md p-3 text-sm">
                    <pre class="whitespace-pre-wrap break-all font-mono text-xs">@headerJson</pre>
                </div>
                <table class="w-full text-sm text-left">
                    <tbody>
                        @foreach (var claim in headerClaims)
                        {
                            <tr class="border-b border-gray-100 last:border-none">
                                <td class="py-1 pr-3 font-semibold text-gray-700">@claim.Key</td>
                                <td class="py-1 text-gray-600">@claim.Value</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 space-y-4">
                <div class="flex items-center justify-between">
                    <h2 class="text-xl font-semibold text-gray-800">Payload</h2>
                    <button id="copy-payload" class="text-gray-500 hover:text-gray-700" @onclick="CopyPayloadAsync" title="Copy payload JSON">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                    </button>
                </div>
                <div class="bg-gray-50 border border-gray-200 rounded-md p-3 text-sm">
                    <pre class="whitespace-pre-wrap break-all font-mono text-xs">@payloadJson</pre>
                </div>
                <div class="space-y-2 text-sm">
                    @if (!string.IsNullOrWhiteSpace(subjectClaim))
                    {
                        <p><span class="font-semibold text-gray-700">Subject:</span> <span class="text-gray-600">@subjectClaim</span></p>
                    }
                    @if (!string.IsNullOrWhiteSpace(audienceClaim))
                    {
                        <p><span class="font-semibold text-gray-700">Audience:</span> <span class="text-gray-600">@audienceClaim</span></p>
                    }
                    @if (!string.IsNullOrWhiteSpace(issuerClaim))
                    {
                        <p><span class="font-semibold text-gray-700">Issuer:</span> <span class="text-gray-600">@issuerClaim</span></p>
                    }
                    @if (!string.IsNullOrWhiteSpace(issuedAtSummary) || !string.IsNullOrWhiteSpace(expiresAtSummary) || !string.IsNullOrWhiteSpace(notBeforeSummary))
                    {
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 text-xs text-gray-500">
                            @if (!string.IsNullOrWhiteSpace(issuedAtSummary))
                            {
                                <div class="bg-gray-50 border border-gray-200 rounded-md p-3">
                                    <span class="block font-semibold uppercase text-gray-500">Issued</span>
                                    <span class="block">@issuedAtSummary</span>
                                </div>
                            }
                            @if (!string.IsNullOrWhiteSpace(notBeforeSummary))
                            {
                                <div class="bg-gray-50 border border-gray-200 rounded-md p-3">
                                    <span class="block font-semibold uppercase text-gray-500">Valid from</span>
                                    <span class="block">@notBeforeSummary</span>
                                </div>
                            }
                            @if (!string.IsNullOrWhiteSpace(expiresAtSummary))
                            {
                                <div class="bg-gray-50 border border-gray-200 rounded-md p-3">
                                    <span class="block font-semibold uppercase text-gray-500">Expires</span>
                                    <span class="block">@expiresAtSummary</span>
                                </div>
                            }
                        </div>
                    }
                </div>
                <table class="w-full text-sm text-left">
                    <tbody>
                        @foreach (var claim in payloadClaims)
                        {
                            <tr class="border-b border-gray-100 last:border-none">
                                <td class="py-1 pr-3 font-semibold text-gray-700">@claim.Key</td>
                                <td class="py-1 text-gray-600">@claim.Value</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 space-y-3">
            <h2 class="text-xl font-semibold text-gray-800">Signature</h2>
            <p class="text-sm text-gray-600">
                The signature verifies the token was issued by a trusted party. You can copy it for debugging or to
                compare with another token.
            </p>
            <div class="flex items-center justify-between bg-gray-50 border border-gray-200 rounded-md p-3 font-mono text-xs break-all">
                <span>@signature</span>
                <button id="copy-signature" class="text-gray-500 hover:text-gray-700 ml-3" @onclick="CopySignatureAsync" title="Copy signature">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                </button>
            </div>
        </div>
    }
</div>

@code {
    private string? jwtInput;
    private string? headerJson;
    private string? payloadJson;
    private Dictionary<string, string>? headerClaims;
    private Dictionary<string, string>? payloadClaims;
    private string? signature;
    private string? decodeError;
    private string? issuedAtSummary;
    private string? expiresAtSummary;
    private string? notBeforeSummary;
    private string? subjectClaim;
    private string? audienceClaim;
    private string? issuerClaim;
    private string? verificationSecret;
    private bool showSecret;
    private SignatureVerificationResult signatureVerification = SignatureVerificationResult.NotRequested();
    private TokenStatus tokenStatus = TokenStatus.Unavailable;
    private string? tokenLifetimeSummary;

    private void DecodeJwt()
    {
        decodeError = null;
        headerJson = null;
        payloadJson = null;
        headerClaims = null;
        payloadClaims = null;
        signature = null;
        issuedAtSummary = null;
        expiresAtSummary = null;
        notBeforeSummary = null;
        subjectClaim = null;
        audienceClaim = null;
        issuerClaim = null;
        signatureVerification = SignatureVerificationResult.NotRequested();
        tokenStatus = TokenStatus.Unavailable;
        tokenLifetimeSummary = null;

        if (string.IsNullOrWhiteSpace(jwtInput))
        {
            decodeError = "Paste a JWT to decode.";
            return;
        }

        var parts = jwtInput.Split('.');
        if (parts.Length < 2)
        {
            decodeError = "A JWT must contain at least a header and payload separated by periods.";
            return;
        }

        try
        {
            var signingInput = $"{parts[0]}.{parts[1]}";
            headerJson = FormatJson(Base64UrlDecode(parts[0]));
            payloadJson = FormatJson(Base64UrlDecode(parts[1]));
            signature = parts.Length > 2 ? parts[2] : string.Empty;

            headerClaims = ParseClaims(headerJson);
            payloadClaims = ParseClaims(payloadJson);

            var algorithm = headerClaims is not null && headerClaims.TryGetValue("alg", out var algValue)
                ? algValue
                : null;

            if (payloadClaims is not null)
            {
                payloadClaims.Remove("exp");
                payloadClaims.Remove("nbf");
                payloadClaims.Remove("iat");
            }

            DateTimeOffset? issuedAt = null;
            DateTimeOffset? expiresAt = null;
            DateTimeOffset? notBefore = null;

            if (!string.IsNullOrWhiteSpace(payloadJson))
            {
                using var payloadDoc = JsonDocument.Parse(payloadJson);
                var root = payloadDoc.RootElement;
                issuedAt = GetUnixTime(root, "iat");
                expiresAt = GetUnixTime(root, "exp");
                notBefore = GetUnixTime(root, "nbf");

                issuedAtSummary = FormatInstant(issuedAt);
                expiresAtSummary = FormatInstant(expiresAt);
                notBeforeSummary = FormatInstant(notBefore);
                subjectClaim = TryGetString(root, "sub");
                issuerClaim = TryGetString(root, "iss");
                audienceClaim = ExtractAudience(root);

                tokenStatus = DetermineTokenStatus(notBefore, expiresAt);
                tokenLifetimeSummary = BuildLifetimeSummary(tokenStatus, notBefore, expiresAt, issuedAt);
            }
            else
            {
                tokenStatus = TokenStatus.Unavailable;
                tokenLifetimeSummary = null;
            }

            signatureVerification = EvaluateSignature(algorithm, signingInput, signature);
        }
        catch (Exception ex)
        {
            decodeError = $"Unable to decode token: {ex.Message}";
        }
    }

    private void ClearAll()
    {
        jwtInput = string.Empty;
        headerJson = null;
        payloadJson = null;
        headerClaims = null;
        payloadClaims = null;
        signature = null;
        decodeError = null;
        issuedAtSummary = null;
        expiresAtSummary = null;
        notBeforeSummary = null;
        subjectClaim = null;
        audienceClaim = null;
        issuerClaim = null;
        signatureVerification = SignatureVerificationResult.NotRequested();
        tokenStatus = TokenStatus.Unavailable;
        tokenLifetimeSummary = null;
    }

    private void ToggleSecretVisibility()
    {
        showSecret = !showSecret;
    }

    private void LoadSampleToken()
    {
        jwtInput = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTEyMyIsIm5hbWUiOiJDYXNleSBFeGFtcGxlIiwicm9sZSI6ImFkbWluIiwiaXNzIjoiaHR0cHM6Ly9jb250b3NvLmV4YW1wbGUiLCJhdWQiOlsiYXBpIiwibW9iaWxlIl0sImlhdCI6MTc3OTk5NjQwMCwibmJmIjoxNzc5OTk2NDAwLCJleHAiOjE3ODAwMDAwMDB9.Ol7RitLH1kg6wY6jdtZxJgSdWhnvhsYEZf9fqwk76s8";
        verificationSecret = "super-secret";
        DecodeJwt();
    }

    private SignatureVerificationResult EvaluateSignature(string? algorithm, string signingInput, string? signatureSegment)
    {
        if (string.IsNullOrWhiteSpace(signatureSegment))
        {
            return SignatureVerificationResult.NotApplicable("Token does not include a signature segment.");
        }

        if (string.Equals(algorithm, "none", StringComparison.OrdinalIgnoreCase))
        {
            return SignatureVerificationResult.NotApplicable("Algorithm 'none' does not produce a signature.");
        }

        if (!SupportsHmac(algorithm))
        {
            return SignatureVerificationResult.Unsupported("Signature verification for this algorithm requires external keys and is not supported offline.");
        }

        var trimmedSecret = verificationSecret?.Trim();
        if (string.IsNullOrEmpty(trimmedSecret))
        {
            return SignatureVerificationResult.SecretRequired("Provide the shared secret to verify the HMAC signature.");
        }

        return VerifyHmacSignature(algorithm!, trimmedSecret, signingInput, signatureSegment);
    }

    private SignatureVerificationResult VerifyHmacSignature(string algorithm, string secret, string signingInput, string signatureSegment)
    {
        try
        {
            var provided = Base64UrlDecodeToBytes(signatureSegment);
            var expected = ComputeHmac(algorithm, secret, signingInput);
            return ConstantTimeEquals(expected, provided)
                ? SignatureVerificationResult.Valid("Signature matches the supplied secret.")
                : SignatureVerificationResult.Invalid("Signature does not match the supplied secret.");
        }
        catch (NotSupportedException)
        {
            return SignatureVerificationResult.Unsupported($"Verification for '{algorithm}' tokens is not available.");
        }
        catch (FormatException)
        {
            return SignatureVerificationResult.Invalid("Signature segment is not valid Base64Url.");
        }
    }

    private static byte[] ComputeHmac(string algorithm, string secret, string signingInput)
    {
        var key = Encoding.UTF8.GetBytes(secret);
        using HMAC hmac = algorithm switch
        {
            "HS256" => new HMACSHA256(key),
            "HS384" => new HMACSHA384(key),
            "HS512" => new HMACSHA512(key),
            _ => throw new NotSupportedException()
        };
        return hmac.ComputeHash(Encoding.UTF8.GetBytes(signingInput));
    }

    private static bool ConstantTimeEquals(byte[] left, byte[] right)
    {
        if (left.Length != right.Length)
        {
            return false;
        }

        var diff = 0;
        for (var i = 0; i < left.Length; i++)
        {
            diff |= left[i] ^ right[i];
        }

        return diff == 0;
    }

    private static bool SupportsHmac(string? algorithm) =>
        algorithm is "HS256" or "HS384" or "HS512";

    private static string Base64UrlDecode(string input)
    {
        var bytes = Base64UrlDecodeToBytes(input);
        return Encoding.UTF8.GetString(bytes);
    }

    private static byte[] Base64UrlDecodeToBytes(string input)
    {
        var sanitized = input.Replace('-', '+').Replace('_', '/');
        switch (sanitized.Length % 4)
        {
            case 2:
                sanitized += "==";
                break;
            case 3:
                sanitized += "=";
                break;
        }

        return Convert.FromBase64String(sanitized);
    }

    private static string FormatJson(string json)
    {
        if (string.IsNullOrWhiteSpace(json))
        {
            return string.Empty;
        }

        using var doc = JsonDocument.Parse(json);
        return JsonSerializer.Serialize(doc.RootElement, new JsonSerializerOptions
        {
            WriteIndented = true
        });
    }

    private static Dictionary<string, string>? ParseClaims(string? json)
    {
        if (string.IsNullOrWhiteSpace(json))
        {
            return null;
        }

        using var doc = JsonDocument.Parse(json);
        var result = new Dictionary<string, string>();
        foreach (var property in doc.RootElement.EnumerateObject())
        {
            result[property.Name] = FormatValue(property.Value);
        }

        return result;
    }

    private static string FormatValue(JsonElement element)
    {
        return element.ValueKind switch
        {
            JsonValueKind.String => element.GetString() ?? string.Empty,
            JsonValueKind.Number => element.TryGetInt64(out var longValue)
                ? longValue.ToString(CultureInfo.InvariantCulture)
                : element.GetDouble().ToString(CultureInfo.InvariantCulture),
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "null",
            JsonValueKind.Array => string.Join(", ", element.EnumerateArray().Select(FormatValue)),
            JsonValueKind.Object => JsonSerializer.Serialize(element, new JsonSerializerOptions { WriteIndented = false }),
            _ => element.ToString()
        };
    }

    private static DateTimeOffset? GetUnixTime(JsonElement root, string propertyName)
    {
        if (!root.TryGetProperty(propertyName, out var element) || element.ValueKind != JsonValueKind.Number)
        {
            return null;
        }

        return element.TryGetInt64(out var unix)
            ? DateTimeOffset.FromUnixTimeSeconds(unix)
            : null;
    }

    private static string? FormatInstant(DateTimeOffset? instant)
    {
        if (instant is null)
        {
            return null;
        }

        var dto = instant.Value.ToUniversalTime();
        return $"{dto:yyyy-MM-dd HH:mm:ss 'UTC'} ({BuildRelative(dto)})";
    }

    private static string? GetTimeClaim(JsonElement root, string propertyName) =>
        FormatInstant(GetUnixTime(root, propertyName));

    private static string BuildRelative(DateTimeOffset dto)
    {
        var diff = DateTimeOffset.UtcNow - dto;
        var direction = diff.TotalSeconds >= 0 ? "ago" : "from now";
        var span = diff.Duration();

        string unit;
        double value;
        if (span.TotalDays >= 1)
        {
            value = span.TotalDays;
            unit = "day";
        }
        else if (span.TotalHours >= 1)
        {
            value = span.TotalHours;
            unit = "hour";
        }
        else if (span.TotalMinutes >= 1)
        {
            value = span.TotalMinutes;
            unit = "minute";
        }
        else
        {
            value = span.TotalSeconds;
            unit = "second";
        }

        var rounded = Math.Max(1, (int)Math.Round(value));
        return rounded == 1
            ? $"{rounded} {unit} {direction}"
            : $"{rounded} {unit}s {direction}";
    }

    private static TokenStatus DetermineTokenStatus(DateTimeOffset? notBefore, DateTimeOffset? expires)
    {
        var now = DateTimeOffset.UtcNow;
        if (notBefore.HasValue && now < notBefore.Value)
        {
            return TokenStatus.NotYetValid;
        }

        if (expires.HasValue && now >= expires.Value)
        {
            return TokenStatus.Expired;
        }

        if (notBefore.HasValue || expires.HasValue)
        {
            return TokenStatus.Valid;
        }

        return TokenStatus.Unavailable;
    }

    private static string? BuildLifetimeSummary(TokenStatus status, DateTimeOffset? notBefore, DateTimeOffset? expires, DateTimeOffset? issuedAt)
    {
        return status switch
        {
            TokenStatus.Valid => BuildValidLifetimeSummary(notBefore, expires, issuedAt),
            TokenStatus.NotYetValid => notBefore.HasValue
                ? $"Token becomes valid at {FormatInstant(notBefore)}."
                : "Token is not yet valid.",
            TokenStatus.Expired => expires.HasValue
                ? $"Token expired at {FormatInstant(expires)}."
                : "Token has expired.",
            _ => null
        };
    }

    private static string BuildValidLifetimeSummary(DateTimeOffset? notBefore, DateTimeOffset? expires, DateTimeOffset? issuedAt)
    {
        var sections = new List<string>();
        var validFrom = FormatInstant(notBefore);
        if (!string.IsNullOrWhiteSpace(validFrom))
        {
            sections.Add($"Valid from {validFrom}");
        }
        else
        {
            var issued = FormatInstant(issuedAt);
            if (!string.IsNullOrWhiteSpace(issued))
            {
                sections.Add($"Issued {issued}");
            }
        }

        var expiresText = FormatInstant(expires);
        sections.Add(!string.IsNullOrWhiteSpace(expiresText)
            ? $"Expires {expiresText}"
            : "No expiry claim present");

        return string.Join(". ", sections);
    }

    private static string? TryGetString(JsonElement root, string propertyName)
    {
        return root.TryGetProperty(propertyName, out var element) && element.ValueKind == JsonValueKind.String
            ? element.GetString()
            : null;
    }

    private static string? ExtractAudience(JsonElement root)
    {
        if (!root.TryGetProperty("aud", out var element))
        {
            return null;
        }

        return element.ValueKind switch
        {
            JsonValueKind.String => element.GetString(),
            JsonValueKind.Array => string.Join(", ", element.EnumerateArray().Select(e => e.ValueKind == JsonValueKind.String ? e.GetString() : e.ToString())),
            _ => element.ToString()
        };
    }

    private static StatusStyle GetTokenStatusStyle(TokenStatus status) => status switch
    {
        TokenStatus.Valid => new StatusStyle("border-green-300", "bg-green-50", "text-green-800", "Token is active"),
        TokenStatus.Expired => new StatusStyle("border-red-300", "bg-red-50", "text-red-800", "Token has expired"),
        TokenStatus.NotYetValid => new StatusStyle("border-amber-300", "bg-amber-50", "text-amber-800", "Token is not yet valid"),
        _ => new StatusStyle("border-gray-300", "bg-gray-50", "text-gray-700", "Token status unavailable")
    };

    private static StatusStyle GetSignatureStatusStyle(SignatureVerificationState state) => state switch
    {
        SignatureVerificationState.Valid => new StatusStyle("border-green-300", "bg-green-50", "text-green-800", "Signature verified"),
        SignatureVerificationState.Invalid => new StatusStyle("border-red-300", "bg-red-50", "text-red-800", "Signature invalid"),
        SignatureVerificationState.SecretRequired => new StatusStyle("border-amber-300", "bg-amber-50", "text-amber-800", "Secret required"),
        SignatureVerificationState.Unsupported => new StatusStyle("border-gray-300", "bg-gray-50", "text-gray-700", "Verification not supported"),
        SignatureVerificationState.NotApplicable => new StatusStyle("border-gray-300", "bg-gray-50", "text-gray-700", "No signature to verify"),
        _ => new StatusStyle("border-gray-200", "bg-gray-50", "text-gray-600", "Signature not checked")
    };

    private Task CopyHeaderAsync() => CopyAsync(headerJson, "copy-header");

    private Task CopyPayloadAsync() => CopyAsync(payloadJson, "copy-payload");

    private Task CopySignatureAsync() => CopyAsync(signature, "copy-signature");

    private async Task CopyAsync(string? value, string buttonId)
    {
        if (!string.IsNullOrWhiteSpace(value))
        {
            await JSRuntime.InvokeVoidAsync("copyToClipboard", value, buttonId);
        }
    }

    private readonly record struct SignatureVerificationResult(SignatureVerificationState State, string Message)
    {
        public static SignatureVerificationResult NotRequested() => new(SignatureVerificationState.NotRequested, string.Empty);
        public static SignatureVerificationResult NotApplicable(string message) => new(SignatureVerificationState.NotApplicable, message);
        public static SignatureVerificationResult Valid(string message) => new(SignatureVerificationState.Valid, message);
        public static SignatureVerificationResult Invalid(string message) => new(SignatureVerificationState.Invalid, message);
        public static SignatureVerificationResult Unsupported(string message) => new(SignatureVerificationState.Unsupported, message);
        public static SignatureVerificationResult SecretRequired(string message) => new(SignatureVerificationState.SecretRequired, message);
    }

    private record StatusStyle(string BorderClass, string BackgroundClass, string TextClass, string Title);

    private enum SignatureVerificationState
    {
        NotRequested,
        Valid,
        Invalid,
        SecretRequired,
        Unsupported,
        NotApplicable
    }

    private enum TokenStatus
    {
        Unavailable,
        Valid,
        Expired,
        NotYetValid
    }
}
